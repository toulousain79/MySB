#!/bin/bash
# ----------------------------------
source $(dirname $0)/../inc/includes_before
# ----------------------------------
#  __/\\\\____________/\\\\___________________/\\\\\\\\\\\____/\\\\\\\\\\\\\___
#   _\/\\\\\\________/\\\\\\_________________/\\\/////////\\\_\/\\\/////////\\\_
#    _\/\\\//\\\____/\\\//\\\____/\\\__/\\\__\//\\\______\///__\/\\\_______\/\\\_
#     _\/\\\\///\\\/\\\/_\/\\\___\//\\\/\\\____\////\\\_________\/\\\\\\\\\\\\\\__
#      _\/\\\__\///\\\/___\/\\\____\//\\\\\________\////\\\______\/\\\/////////\\\_
#       _\/\\\____\///_____\/\\\_____\//\\\____________\////\\\___\/\\\_______\/\\\_
#        _\/\\\_____________\/\\\__/\\_/\\\______/\\\______\//\\\__\/\\\_______\/\\\_
#         _\/\\\_____________\/\\\_\//\\\\/______\///\\\\\\\\\\\/___\/\\\\\\\\\\\\\/__
#          _\///______________\///___\////__________\///////////_____\/////////////_____
#			By toulousain79 ---> https://github.com/toulousain79/
#
######################################################################
#
#	Copyright (c) 2013 toulousain79 (https://github.com/toulousain79/)
#	Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
#	The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
#	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
#	IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#	--> Licensed under the MIT license: http://www.opensource.org/licenses/mit-license.php
#
##################### FIRST LINE #####################################
#
# Usage:	MySB_SecurityRules {clean|create|refresh}
#
##################### FIRST LINE #####################################

source $MySB_InstallDir/inc/funcs_iptables

#### VARs
Switch="$1"
ListingUsers #($UsersList)
AllUsersIPs="${SeedboxUsersIPs} ${MainUserIPs}"
AllUsersIPs=$(echo "$AllUsersIPs"|tr " " "\n"|sort|uniq|tr "\n" " ") # sort as uniq
ServicesToRestart=""
ServicesToStop=""
#### VARs

#### Check arguments options
LoadModules=NO
LoadKernelParameter=NO
ApplyConfigNginx=NO
ApplyConfigPeerGuardian=NO
ApplyConfigFail2Ban=NO
ApplyConfigBind=NO
ApplyIptablesUsers=NO
ApplyIptablesLetsEncrypt=NO
LoadOnBoot=NO

# Check by arguments
for Arg in "$@"; do
	case "$Arg" in
		INSTALL|UPGRADE)
			LoadKernelModules=YES
			LoadKernelParameter=YES
		;;
		INIT)
			LoadKernelModules=YES
			LoadKernelParameter=YES
			LoadOnBoot=YES
		;;
	esac
done

case "$Switch" in
	create)
		ApplyConfigNginx="`CheckCommand 1 nginx`"
		ApplyConfigPeerGuardian=$IsInstalled_PeerGuardian
		ApplyConfigFail2Ban=$IsInstalled_Fail2Ban
		ApplyConfigBind="`CheckCommand 1 named`"
	;;
	clean)
		ApplyConfigNginx="`CheckCommand 1 nginx`"
		ApplyConfigBind="`CheckCommand 1 named`"
	;;
	refresh)
		for Arg in "$@"; do
			case "$Arg" in
				--letsencrypt)
					unset LentsEncryptIPs Temp
					LetsEncryptOpenPort="`Func_SQL_Command 'SELECT' 'MySB_db' 'letsencrypt_openport' 'system' "id_system = 1"`"
					Temp="`Func_SQL_Command 'SELECT' 'MySB_db' 'ipv4' 'lets_encrypt' "1" | sed -e 's/^ //g;' | sed 's/\s+$//'`"
					if [ "$IpRestriction" == "YES" ]; then
						for ip in $Temp; do
							LentsEncryptIPs="${LentsEncryptIPs} $ip/32"
						done
					else
						LentsEncryptIPs="0/0"
					fi
					LentsEncryptIPs=$(echo "$LentsEncryptIPs"|tr " " "\n"|sort|uniq|tr "\n" " ") # sort as uniq
					ApplyIptablesLetsEncrypt=YES
					ApplyConfigPeerGuardian=$IsInstalled_PeerGuardian
				;;
				--users)
					ApplyIptablesUsers=YES
					ApplyConfigNginx="`CheckCommand 1 nginx`"
					ApplyConfigFail2Ban=$IsInstalled_Fail2Ban
					ApplyConfigPeerGuardian=$IsInstalled_PeerGuardian
				;;
				--trackers)
					ApplyConfigBind="`CheckCommand 1 named`"
					ApplyConfigPeerGuardian=$IsInstalled_PeerGuardian
				;;
				--blocklists)
					ApplyConfigBind="`CheckCommand 1 named`"
					ApplyConfigPeerGuardian=$IsInstalled_PeerGuardian
				;;
				--pglcmd)
					ApplyIptablesUsers=YES
					ApplyConfigPeerGuardian=$IsInstalled_PeerGuardian
				;;
				--all)
					ApplyIptablesUsers=YES
					ApplyConfigNginx="`CheckCommand 1 nginx`"
					ApplyConfigBind="`CheckCommand 1 named`"
					ApplyConfigFail2Ban=$IsInstalled_Fail2Ban
					ApplyConfigPeerGuardian=$IsInstalled_PeerGuardian
				;;
			esac
		done
	;;
esac

if [ "$ApplyConfigBind" == "YES" ]; then
	ServicesToRestart="${ServicesToRestart} bind9"
fi
if [ "$ApplyConfigFail2Ban" == "YES" ]; then
	ServicesToRestart="${ServicesToRestart} fail2ban"
fi
if [ "$ApplyConfigPeerGuardian" == "YES" ]; then
	ServicesToRestart="${ServicesToRestart} pglcmd"
fi
if [ "$ApplyConfigNginx" == "YES" ]; then
	ServicesToRestart="${ServicesToRestart} nginx"
fi
case "$DNScrypt_Switch" in
	"0")
		ServicesToStop="dnscrypt-proxy"
	;;
	"1")
		if ! GetPid dnscrypt-proxy; then
			ServicesToRestart="${ServicesToRestart} dnscrypt-proxy"
		fi
	;;
esac
#### Check arguments options

#### Functions
# Create all rules for services (config files)
CreateServicesRules() {
	#### NginX
	if [ "$ApplyConfigNginx" == "YES" ] && [ "$IpRestriction" == "YES" ]; then
		log_daemon_msg "$SecurityRules_NginX_AllUsers"
		echo "	# Users allowed IP" > /etc/nginx/conf.d/ip_restriction
		for IPv4 in $AllUsersIPs; do
			echo "	allow $IPv4;" >> /etc/nginx/conf.d/ip_restriction
		done
		unset IPv4
		StatusLSB
	fi
	#### NginX

	#### NginX
	if [ "$ApplyConfigNginx" == "YES" ]; then
		if [ "$IpRestriction" == "YES" ]; then
			if [ "$IsInstalled_OpenVPN" == "YES" ]; then
				# OpenVPN local IP addresses
				log_daemon_msg "$SecurityRules_NginX_OpenVPN"
				echo "	# Restricted IP for OpenVPN users" >> /etc/nginx/conf.d/ip_restriction
				for IPv4 in $VpnIPs; do
					echo "	allow $IPv4;" >> /etc/nginx/conf.d/ip_restriction
				done
				unset IPv4
				StatusLSB
			fi

			# Loopback
			log_daemon_msg "$SecurityRules_NginX_Loopback"
			echo "	# Localhost" >> /etc/nginx/conf.d/ip_restriction
			echo "	allow 127.0.0.1;" >> /etc/nginx/conf.d/ip_restriction
			StatusLSB

			# Deny all others
			echo "	# Deny all others" >> /etc/nginx/conf.d/ip_restriction
			echo "	deny all;" >> /etc/nginx/conf.d/ip_restriction
		else
			log_daemon_msg "$SecurityRules_NginX_SatisfyAll"
			echo "	# Allow any one" >> /etc/nginx/conf.d/ip_restriction
			echo "	satisfy all;" > /etc/nginx/conf.d/ip_restriction
			StatusLSB
		fi
	fi
	#### NginX

	#### BIND
	if [ "$ApplyConfigBind" == "YES" ]; then
		log_daemon_msg "$SecurityRules_Bind_BlockOut"
		echo "#### MySB - Blacklisted domains (ex: inactive trackers)" > /etc/bind/MySB.zones.blakclists
		AllTrackersDomain="`Func_SQL_Command 'SELECT' 'MySB_db' 'tracker_domain' 'trackers_list' \"is_active = '0' AND to_check = '0'\"`"
		for TrackerDomain in $AllTrackersDomain; do
			echo "zone \"$TrackerDomain\" { type master; file \"/etc/bind/db.empty\"; };" >> /etc/bind/MySB.zones.blakclists
		done
		perl -pi -e "s/^#include \"\/etc\/bind\/MySB.zones.blakclists\";/include \"\/etc\/bind\/MySB.zones.blakclists\";/g" /etc/bind/named.conf.local
		StatusLSB 0

		log_daemon_msg "$SecurityRules_Bind_TrackersHosts"
		CreateHostsFile
		StatusLSB 0
	fi
	#### BIND

	#### Fail2Ban
	if [ "$ApplyConfigFail2Ban" == "YES" ]; then
		source $MySB_InstallDir/inc/funcs_by_script/funcs_Fail2Ban
		Fail2BanWhitheList 1
	fi
	#### Fail2Ban

	#### PeerGuardian
	if [ "$ApplyConfigPeerGuardian" == "YES" ]; then
		if [ -z $funcs_PeerGuardian ]; then
			source $MySB_InstallDir/inc/funcs_by_script/funcs_PeerGuardian
		fi

		# Create '/etc/pgl/pglcmd.conf'
		PeerGuardianPglcmdConf 0
		if [ "$LetsEncryptOpenPort" == "0" ]; then
			# Create '/etc/pgl/allow.p2p'
			PeerGuardianAllowP2P 0
			# Create '/etc/pgl/blocklists.list'
			PeerGuardianBlocklistsList 0 "CreateFile"
			# Create '/etc/pgl/*.insert.sh'
			PeerGuardianIptablesInsert 0
		fi
	fi
	#### PeerGuardian
}

# Restart all rTorrent session if needed
RestartRtorrentSessions() {
	case "$1" in
		stop)
			for FnUser in $UsersList; do
				if [ -f /etc/init.d/rtorrent-$FnUser ]; then
					service rtorrent-$FnUser stop
				fi
			done
		;;
		start)
			service cron status > /dev/null
			if [ $? -eq 0 ]; then
				for FnUser in $UsersList; do
					if [ -f /etc/init.d/rtorrent-$FnUser ]; then
						service rtorrent-$FnUser status &> /dev/null
						if [ $? -ne 0 ]; then
							service rtorrent-$FnUser restart
						fi
					fi
				done
			fi
		;;
	esac
}
#### Functions

#### Begin
case "$Switch" in
	clean)
		#### STOP services
		RestartRtorrentSessions "stop"
		ManageServices stop "pglcmd fail2ban cron"
		#### STOP services

		#### IPtables - Removal of existing rules
		log_daemon_msg "$SecurityRules_IPtables_RemoveAll"
		FlushingTables
		StatusLSB
		#### IPtables - Removal of existing rules

		#### NginX - Satisfy all
		if [ "$ApplyConfigNginx" == "YES" ]; then
			log_daemon_msg "$SecurityRules_NginX_SatisfyAll"
			echo "	# Allow any one" >> /etc/nginx/conf.d/ip_restriction
			echo "	satisfy all;" > /etc/nginx/conf.d/ip_restriction
			StatusLSB
		else
			log_daemon_msg "$SecurityRules_NginX_NotInstalled"
			StatusLSB
		fi
		#### NginX - Satisfy all

		#### Bind - Unblock inactive tracker domains
		if [ "$ApplyConfigBind" == "YES" ]; then
			log_daemon_msg "$SecurityRules_Bind_UnblockTracker"
			perl -pi -e "s/^include \"\/etc\/bind\/MySB.zones.blakclists\";/#include \"\/etc\/bind\/MySB.zones.blakclists\";/g" /etc/bind/named.conf.local
			StatusLSB
		else
			log_daemon_msg "$SecurityRules_Bind_NotInstalled"
			StatusLSB
		fi
		#### Bind - Unblock inactive tracker domains

		#### START services
		ManageServices start "nginx bind9"
		#### START services

		#### STOP services
		ManageServices stop "$ServicesToStop"
		#### STOP services

		#### IPtables - SAVE Iptables Rules
		iptables-save > /etc/iptables.up.rules
		cp /etc/iptables.up.rules $MySB_InstallDir/files/current-iptables-rules
		if [ "$IsInstalled_Webmin" == "YES" ] && [ -d /etc/webmin/firewall/ ]; then
			cp /etc/iptables.up.rules /etc/webmin/firewall/iptables.save
		fi
		#### IPtables - SAVE Iptables Rules
	;;

	create)
		#### STOP services
		RestartRtorrentSessions "stop"
		ManageServices stop "cron pglcmd fail2ban"
		#### STOP services

		#### Kernel - Loading modules
		log_daemon_msg "$SecurityRules_Kernel_Loading"
		if [ "$LoadKernelModules" == "YES" ]; then
			LoadingKernelModules
		fi
		StatusLSB
		#### Kernel - Loading modules

		#### Kernel - Parameter Configuration
		log_daemon_msg "$SecurityRules_Kernel_Parameter"
		if [ "$LoadKernelParameter" == "YES" ]; then
			KernelParameterConfiguration
		fi
		StatusLSB
		#### Kernel - Parameter Configuration

		#### IPtables - Removal of existing rules
		log_daemon_msg "$SecurityRules_IPtables_RemoveAll"
		FlushingTables
		StatusLSB
		#### IPtables - Removal of existing rules

		#### IPtables - Prohibit any incoming/outgoing connections
		log_daemon_msg "$SecurityRules_IPtables_ProhibitConn"
		iptables -P INPUT DROP
		iptables -P FORWARD DROP
		iptables -P OUTPUT DROP
		StatusLSB
		#### IPtables - Prohibit any incoming/outgoing connections

		#### IPtables - Creating user chains
		log_daemon_msg "$SecurityRules_IPtables_UserChains"
		CreatingUserChain
		StatusLSB
		#### IPtables - Creating user chains

		#### IPtables - Populating user chains
		log_daemon_msg "$SecurityRules_IPtables_BadChains"
		PopulatingBadChain
		StatusLSB
		#### IPtables - Populating user chains

		#### IPtables - Populating ICMP chain
		Message="$SecurityRules_IPtables_ICMP_0"
		if [ ! -z "$ServerProvider" ] && [ "$ServerProvider" != "$Global_NO" ]; then
			Message="$SecurityRules_IPtables_ICMP_1"
		fi
		log_daemon_msg "$Message"
		PopulatingIcmpChain 'create'
		StatusLSB
		#### IPtables - Populating ICMP chain

		#### IPtables - Populating UDP inboud user chain
		log_daemon_msg "$SecurityRules_IPtables_UdpIn"
		PopulatingUdpInboundChain 'create'
		StatusLSB
		#### IPtables - Populating UDP inboud chain

		#### IPtables - Populating UDP outbound chain
		log_daemon_msg "$SecurityRules_IPtables_UdpOut"
		PopulatingUdpOutboundChain
		StatusLSB
		#### IPtables - Populating UDP outbound chain

		#### IPtables - Populating TCP inboud user chain
		log_daemon_msg "$SecurityRules_IPtables_TcpIn"
		PopulatingTcpInboundChain 'create'
		StatusLSB
		#### IPtables - Populating TCP inboud chain

		#### IPtables - Populating TCP outbound user chain
		log_daemon_msg "$SecurityRules_IPtables_TcpOut"
		PopulatingTcpOutboundChain
		StatusLSB
		#### IPtables - Populating TCP outbound chain

		#### IPtables - Process INPUT chain
		log_daemon_msg "$SecurityRules_IPtables_Input"
		ProcessInputChain
		StatusLSB
		#### IPtables - Process INPUT chain

		#### IPtables - Process FORWARD chain
		log_daemon_msg "$SecurityRules_IPtables_Forward"
		ProcessForwardChain
		StatusLSB
		#### IPtables - Process FORWARD chain

		#### IPtables - Process OUTPUT chain
		log_daemon_msg "$SecurityRules_IPtables_Output"
		ProcessOutputChain
		StatusLSB
		#### IPtables - Process OUTPUT chain

		#### IPtables - Process POSTROUTING chain
		log_daemon_msg "$SecurityRules_IPtables_Postrouting"
		ProcessPostroutingChain
		StatusLSB
		#### IPtables - Process POSTROUTING chain

		#### Services - Create all security rules for services
		CreateServicesRules
		#### Services - Create all security rules for services

		#### START services
		ManageServices start "cron $ServicesToRestart"
		RestartRtorrentSessions "start"
		#### START services

		#### STOP services
		ManageServices stop "$ServicesToStop"
		#### STOP services

		#### Save Iptables Rules for Webmin
		iptables-save > /etc/iptables.up.rules
		cp /etc/iptables.up.rules $MySB_InstallDir/files/current-iptables-rules
		if [ "$IsInstalled_Webmin" == "YES" ] && [ -d /etc/webmin/firewall/ ]; then
			cp /etc/iptables.up.rules /etc/webmin/firewall/iptables.save
		fi
		#### Save Iptables Rules for Webmin

		#### Complete the previous upgrade
		if [ "$LoadOnBoot" == "YES" ]; then
			ScriptOnBoot="`Func_SQL_Command 'SELECT' 'MySB_db' 'name,script' 'repositories' \"on_boot = '1' AND active = '1'\"`"
			if [ ! -z "$ScriptOnBoot" ]; then
				IFS=$'\n'
				for Script in $ScriptOnBoot; do
					Name="`echo $Script | awk '{split($0,a,"|"); print a[1]}'`"
					File="`echo $Script | awk '{split($0,a,"|"); print a[2]}'`"

					log_daemon_msg "$SecurityRules_UpgradeEnd $Name"
					ScriptInvoke 'ScreenSTD' "$File" 'INIT'
					StatusLSB
				done
				unset IFS
			fi
		fi
	;;

	refresh)
		#### IPtables - SAVE Iptables Rules
		log_daemon_msg "$SecurityRules_IPtables_Save"
		if [ -f $MySB_InstallDir/temp/current-iptables-rules ]; then
			rm -f $MySB_InstallDir/temp/current-iptables-rules
		fi
		iptables-save > $MySB_InstallDir/temp/current-iptables-rules
		StatusLSB
		#### IPtables - SAVE Iptables Rules

		#### IPtables - ALTER Iptables Rules
		if [ "$ApplyIptablesLetsEncrypt" == "YES" ]; then
			log_daemon_msg "$SecurityRules_IPtables_LetEncrypt"

			# icmp_packets chain
			PopulatingIcmpChain 'letsencrypt'
			# icmp_packets chain

			# tcp_inbound chain
			PopulatingTcpInboundChain 'letsencrypt'
			# tcp_inbound chain

			StatusLSB
		fi		
		if [ "$ApplyIptablesUsers" == "YES" ]; then
			log_daemon_msg "$SecurityRules_IPtables_Refresh"

			# icmp_packets chain
			PopulatingIcmpChain 'refresh'
			# icmp_packets chain

			# udp_inbound chain
			PopulatingUdpInboundChain 'refresh'
			# udp_inbound chain

			# tcp_inbound chain
			PopulatingTcpInboundChain 'refresh'
			# tcp_inbound chain

			StatusLSB
		fi
		if [ "$ApplyIptablesDnscrypt" == "YES" ]; then
			NumLign=$(cat $MySB_InstallDir/temp/current-iptables-rules | grep 'DNScrypt-proxy' -n -m 1 | cut -d ':' -f 1)
			sed -i '/DNScrypt-proxy/d' $MySB_InstallDir/temp/current-iptables-rules

			ResolverName="`Func_SQL_Command 'SELECT' 'MySB_db' 'name' 'dnscrypt_resolvers' \"is_wished = '1'\"`"
			for Resolver in $ResolverName; do
				ResolverAddress="`Func_SQL_Command 'SELECT' 'MySB_db' 'resolver_address' 'dnscrypt_resolvers' "name = '$Resolver'"`"
				ResolverPort="`echo $ResolverAddress | awk -F: '{ print $2 }'`"
				ResolverAddress="`echo $ResolverAddress | awk -F: '{ print $1 }'`"
				if [ -z "$ResolverPort" ]; then ResolverPort="443"; fi

				sed -i ""$NumLign"i\-A udp_inbound -s $ResolverAddress/32 -p udp -m udp --dport $ResolverPort -m comment --comment \"DNScrypt-proxy: $Resolver\" -j ACCEPT" $MySB_InstallDir/temp/current-iptables-rules
			done
		fi
		#### IPtables - ALTER Iptables Rules

		#### Services - Create all security rules for services
		CreateServicesRules
		#### Services - Create all security rules for services

		#### IPtables - RESTORE Iptables Rules
		log_daemon_msg "$SecurityRules_IPtables_Restore"
		iptables-restore < $MySB_InstallDir/temp/current-iptables-rules
		StatusLSB
		#### IPtables - RESTORE Iptables Rules

		#### START services
		ManageServices start "$ServicesToRestart"
		#### START services

		#### STOP services
		ManageServices stop "$ServicesToStop"
		#### STOP services

		#### Save Iptables Rules for Webmin
		iptables-save > /etc/iptables.up.rules
		cp /etc/iptables.up.rules $MySB_InstallDir/files/current-iptables-rules
		if [ "$IsInstalled_Webmin" == "YES" ] && [ -d /etc/webmin/firewall/ ]; then
			cp /etc/iptables.up.rules /etc/webmin/firewall/iptables.save
		fi

		if CheckCommand 0 postfix && GetPid $Service; then postfix flush; fi

		RestartRtorrentSessions "start"
	;;

	*)
		echo -e "$SecurityRules_Usage"
		echo
		END=OFF
		EndingScript 0
	;;
esac

# -----------------------------------------
source $(dirname $0)/../inc/includes_after
# -----------------------------------------
##################### LAST LINE ######################################