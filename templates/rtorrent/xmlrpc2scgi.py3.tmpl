#!/usr/bin/env python3

"""
# https://github.com/rakshasa/rtorrent-vagrant/blob/master/scripts/xmlrpc2scgi.py
"""

import sys
from io import StringIO
import xmlrpc.client
from urllib.parse import urlparse, splitport, uses_netloc
import socket

uses_netloc.append('scgi')


def do_scgi_xmlrpc_request(host, methodname, params=()):
    """[summary]

    Args:
        host ([type]): [description]
        methodname ([type]): [description]
        params (tuple, optional): [description]. Defaults to ().

    Returns:
        [type]: [description]
    """
    xmlreq = xmlrpc.client.dumps(params, methodname)
    xmlresp = SCGIRequest(host).send(xmlreq)
    return xmlresp


def do_scgi_xmlrpc_request_py(host, methodname, params=()):
    """[summary]

    Args:
        host ([type]): [description]
        methodname ([type]): [description]
        params (tuple, optional): [description]. Defaults to ().

    Returns:
        [type]: [description]
    """
    xmlresp = do_scgi_xmlrpc_request(host, methodname, params)
    return xmlrpc.client.loads(xmlresp)[0][0]


class SCGIRequest(object):
    """[summary]

    Args:
        object ([type]): [description]

    Returns:
        [type]: [description]
    """

    def __init__(self, url):
        self.url = url
        self.resp_headers = []

    def __send(self, scgireq):
        res = urlparse(self.url)
        host, port = splitport(res.netloc)

        if res.netloc:
            inet6_host = ''

            if inet6_host:
                addrinfo = socket.getaddrinfo(
                    inet6_host, port, socket.AF_INET6, socket.SOCK_STREAM)
            else:
                addrinfo = socket.getaddrinfo(
                    host, port, socket.AF_INET, socket.SOCK_STREAM)

            assert len(addrinfo) == 1, "There's more than one? %r" % addrinfo

            sock = socket.socket(*addrinfo[0][:3])
            sock.connect(addrinfo[0][4])
        else:
            sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
            sock.connect(res.path)

        sock.send(scgireq)
        recvdata = resp = sock.recv(1024)

        while recvdata != '':
            recvdata = sock.recv(1024)
            resp += recvdata
        sock.close()
        return resp

    def send(self, data):
        "Send data over scgi to url and get response"
        scgiresp = self.__send(self.add_required_scgi_headers(data))
        resp, self.resp_headers = self.get_scgi_resp(scgiresp)
        return resp

    @staticmethod
    def encode_netstring(string):
        "Encode string as netstring"
        return '%d:%s,' % (len(string), string)

    @staticmethod
    def make_headers(headers):
        "Make scgi header list"
        return '\x00'.join(['%s\x00%s' % t for t in headers])+'\x00'

    @staticmethod
    def add_required_scgi_headers(data, headers=None):
        "Wrap data in an scgi request,\nsee spec at: http://python.ca/scgi/protocol.txt"
        headers = SCGIRequest.make_headers(
            [('CONTENT_LENGTH', str(len(data))), ('SCGI', '1'), ] + headers)
        enc_headers = SCGIRequest.encode_netstring(headers)
        return enc_headers+data

    @staticmethod
    def gen_headers(file):
        "Get header lines from scgi response"
        line = file.readline().rstrip()

        while line.strip():
            yield line
            line = file.readline().rstrip()

    @staticmethod
    def get_scgi_resp(resp):
        "Get xmlrpc response from scgi response"
        fresp = StringIO(resp)
        headers = []

        for line in SCGIRequest.gen_headers(fresp):
            headers.append(line.split(': ', 1))

        xmlresp = fresp.read()
        return (xmlresp, headers)


class RTorrentXMLRPCClient(object):
    """[summary]

    Args:
        object ([type]): [description]

    Raises:
        Exception: [description]
        Exception: [description]
        Exception: [description]

    Returns:
        [type]: [description]
    """

    def __init__(self, url, methodname=''):
        self.url = url
        self.methodname = methodname

    def __call__(self, *args):
        res = urlparse(self.url)
        xmlreq = xmlrpc.client.dumps(args, self.methodname)

        if res.scheme == 'scgi':
            xmlresp = SCGIRequest(self.url).send(xmlreq)
            return xmlrpc.client.loads(xmlresp)[0][0]
        elif res.scheme == 'http':
            raise Exception('Unsupported protocol')
        elif res.scheme == '':
            raise Exception('Unsupported protocol')
        else:
            raise Exception('Unsupported protocol')

    def __getattr__(self, attr):
        methodname = self.methodname and '.'.join(
            [self.methodname, attr]) or attr
        return RTorrentXMLRPCClient(self.url, methodname)


def convert_params_to_native(params):
    "Parse xmlrpc-c command line arg syntax"
    cparams = []

    for param in params:
        if len(param) < 2 or param[1] != '/':
            cparams.append(param)
            continue
        if param[0] == 'i':
            ptype = int
        elif param[0] == 'b':
            ptype = bool
        elif param[0] == 's':
            ptype = str
        else:
            cparams.append(param)
            continue
        cparams.append(ptype(param[2:]))

    return tuple(cparams)


def print_script(response):
    """[summary]

    Args:
        response ([type]): [description]
    """
    if isinstance(response, int):
        print(response)
    elif isinstance(response, str):
        print(response).encode('utf-8')
    else:
        for line in response:
            print(" ".join(map(str, line)).encode('utf-8'))


def main(argv):
    """[summary]

    Args:
        argv ([type]): [description]
    """
    if len(argv) < 1:
        print("No arguments.")
        exit(1)

    if len(argv[0]) and argv[0][0] == '-':
        output_arg = argv[0]
        argv.pop(0)

    if len(argv) < 2:
        print("Too few arguments.")
        exit(1)

    host, methodname = argv[:2]
    respxml = do_scgi_xmlrpc_request(
        host, methodname, convert_params_to_native(argv[2:]))
    result = xmlrpc.client.loads(respxml)[0][0]

    if output_arg == '-p':
        if isinstance(result, str):
            print(result.encode('utf-8'))
        else:
            print(result)
    elif output_arg == '-s':
        print_script(result)
    else:
        print(respxml)


if __name__ == "__main__":
    try:
        main(sys.argv[1:])
    except xmlrpc.client.Fault as err:
        print("xmlrpc.client.Fault({0}): {1}".format(
            err.faultCode, err.faultString))
