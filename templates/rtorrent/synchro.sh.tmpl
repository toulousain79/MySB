#!/bin/bash

#### VARs
# Destination
ModeSync="ftp"		# ftp OR rsync
DstDir="./"			# Destination directory, WITH starting './' and WITHOUT ending '/'. (ex: ./home/myuser)
DstSrv=""			# Hostname OR IP address of the destination. (ex: myserver.mydomain.com)
DstPort=""			# Port (ex: 22)
DstUser=""			# Username
DstPass=""			# Password
MaxToSync=0			# Max file to synchronize from 'FileList' per cronjob ? (0 for sync all)
CreateSubDir=1		# 1: Create a subdirectory for alone files (needed by some scraper) | 0: Do not create subdirectory
# Notification (if enabled on MySB options page in portal)
MailObjectOK="MySB - Transfert vers le NAS terminé !"
MailObjectKO="MySB - Transfert vers le NAS échoué !"

#### DO NOT MODIFY
UserName="`whoami`"
ScriptName=$(basename $0)
CompleteDir="$HOME/rtorrent/complete/"
DataBase="$HOME/db/$UserName.sq3"
FileLockDirect="$HOME/scripts/direct.lock"
FileLockCron="$HOME/scripts/cron.lock"
FileLog="$HOME/logs/$ScriptName.log"
RsyncCipher="aes128-ctr"
PID="$$"
get_base_path="$1"
get_custom1="$2"
get_name="$3"
get_loaded_file="$4"
#### DO NOT MODIFY

#### START BY: CRON (without args) or DIRECTLY (with args after a download) ?
if [ -z "$get_base_path" ] || [ -z "$get_custom1" ] || [ -z "$get_name" ] || [ -z "$get_loaded_file" ]; then
	CronMode=1
else
	CronMode=0
fi

#### LIST ADD:  Started DIECTLY means that we must add download informations to a list (or not).
if [ $CronMode -eq 0 ]; then
	# Sync Mode for finished download
	# 0	-->	Do not start any script (no synchro)
	# 1	-->	Execute scripts by crontab
	# 2	-->	Execute scripts directly when a download is finished
	CompleteDirEscaped="`echo $CompleteDir | sed s,/,\\\\\\\\\\/,g`"
	CategoryDir="`echo $get_custom1 | sed "s/$CompleteDirEscaped//g;" | sed 's/\///g;'`"
	CategoryList="`sqlite3 -cmd '.timeout 150000' $DataBase "SELECT sync_mode FROM categories WHERE name = '$CategoryDir';"`"
	case "$CategoryList" in
		1)
			CategoryList="cron"
		;;
		2)
			CategoryList="direct"
		;;
		*)
			exit 0
		;;
	esac

	# Add entry to the list (cron OR direct)
	sqlite3 -cmd '.timeout 150000' $DataBase "INSERT INTO list (list_category,is_active,get_base_path,get_custom1,get_name,get_loaded_file,CategoryDir) VALUES ('$CategoryList','1','$get_base_path','$get_custom1','$get_name','$get_loaded_file','$CategoryDir');"

	# We are in direct sync mode
	CategoryList="direct"
	FileLock="$FileLockDirect"
else
	# We are in cron sync mode
	CategoryList="cron"
	FileLock="$FileLockCron"
fi

#### LOCKED: If a lock file exists means that synchronization is already in progress. Same thing if the list is empty.
InQueue="`sqlite3 -cmd '.timeout 150000' $DataBase "SELECT count(*) FROM list WHERE list_category = '$CategoryList' AND is_active = '1';"`"
if [ -e $FileLock ]; then				# Check that the lock file has not been forgotten...
	GetPid="`cat $FileLock`"
	case "`ps -p $GetPid &>/dev/null`" in
		0)								# The script is still running, the lock file is legitimate. We can stop the script.
			exit 0
		;;
		*)								# Otherwise, we remove it and continue running the script.
			rm -f $FileLock
			if [ -e /tmp/$UserName-$ScriptName.log.$GetPid ]; then
				rm -f /tmp/$UserName-$ScriptName.log.$GetPid
			fi
			if [ $InQueue -eq 0 ]; then	# The list is empty, there is nothing to do. So we stop the script.
				exit 0
			else						# Otherwise, we continue and create a new lock file.
				echo $PID > $FileLock
			fi
		;;
	esac
else									# No file locking, we continue.
	if [ $InQueue -eq 0 ]; then			# The list is empty, there is nothing to do. So we stop the script.
		exit 0
	else								# Otherwise, we continue and create a new lock file.
		echo $PID > $FileLock
	fi
fi

############ FUNCTIONs - BoF ############

#### Retrieving files to transfer
Listing() {
	# VARs
	FnGet_List_ID="$1"
	FnGet_Base_Bath="$2"
	FnGet_Custom1="$3"
	FnGet_Name="$4"
	FnGet_LoadedFile="$5"
	FnCategoryDir="$6"
	FnGet_NameEscaped="`echo $FnGet_Name | sed s,/,\\\\\\\\\\/,g`"
	FnLine="$FnGet_Custom1$FnGet_Name"
	FnMail_Object="$MailObjectOK"

	# Check if files exist
	FnCheck="`file "$FnLine"`"
	if [ $? -ne 0 ]; then
		ModeSync="no_such_file_or_directory"
	else
		Type="`echo $FnCheck | cut -d ":" -f 2 | sed -e 's/^ //g;' | sed 's/\s+$//'`"
	fi

	# Need to create a subdirectory on destination ?
	if [ -f "$FnLine" ] && [ $CreateSubDir -eq 1 ]; then
		FnGet_NameEscaped="`echo $FnGet_NameEscaped | sed 's/\[/\\\[/g;' | sed 's/\]/\\\]/g;' | sed 's/(/\\(/g' | sed 's/)/\\)/g'`"
		FnSubDirectory="`echo $FnLine | sed "s/$FnGet_NameEscaped//g;" | sed s,/,\\\\\\\\\\/,g`"
		FnSubDirectory="`echo ${FnLine%.*} | sed "s/$FnSubDirectory//g;" | sed -e 's/^ //g;' | sed 's/\s+$//'`"
	fi

	if [ ! -z "$FnSubDirectory" ] && [ $CreateSubDir -eq 1 ]; then
		FnDstDir="$DstDir/$FnCategoryDir/$FnSubDirectory"
	else
		FnDstDir="$DstDir/$FnCategoryDir"
	fi
	FnDstDir="`echo $FnDstDir | sed -e 's/^ //g;' | sed 's/\s+$//'`"
	FnDstDir="`echo $FnDstDir | sed 's/\[//g;' | sed 's/\]//g;' | sed 's/(//g' | sed 's/)//g' | sed 's/\ /./g;' | sed -e 's/\/\//\//g;'`"

	# Log
	echo "#### START ####"
	echo "Script:		$0"
	echo "From:		$FnLine"
	echo "To:		$FnDstDir"
	echo "Category:	$FnCategoryDir"
	echo "Server:		$DstUser@$DstSrv"
	echo "Date:		`/bin/date +%Y/%m/%d`"
	echo "Hour:		`/bin/date +%H:%M:%S`"
	echo "--------------------"
	echo

	case "$ModeSync" in
		'rsync')
			# Start synchronization with RSYNC
			# Creating sub-directory on destination
			sshpass -p $DstPass ssh -p $DstPort -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null $DstUser@$DstSrv "if [ ! -d \"$FnDstDir\" ]; then mkdir -p \"$FnDstDir\"; fi"

			# Start synchronization with RSYNC
			rsync -rtvy --numeric-ids --partial --append --stats --timeout=10 -e "/usr/bin/sshpass -p$DstPass ssh -p $DstPort -c $RsyncCipher -o Compression=no -x -T -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null" "$FnLine" $DstUser@$DstSrv:"$FnDstDir/"
		;;
		'ftp')
			LftpOptions="set ftp:ssl-protect-data true; set ssl:verify-certificate no; set net:max-retries 3; set net:reconnect-interval-base 5;"
			case "$Type" in
				'directory')
					lftp -e "$LftpOptions mkdir -p \"$FnDstDir/$FnGet_NameEscaped\"; mirror -R \"$FnLine\" \"$FnDstDir/$FnGet_NameEscaped\"; bye" -u "$DstUser","$DstPass" "$DstSrv" -p "$DstPort"
				;;
				*)
					lftp -e "$LftpOptions mkdir -p $FnDstDir; put -O \"$FnDstDir\" \"$FnLine\"; bye" -u "$DstUser","$DstPass" "$DstSrv" -p "$DstPort"
				;;
			esac
		;;
		'no_such_file_or_directory')
			echo $FnCheck
		;;
		*)
			return 1
		;;
	esac

	# Deleting the file from the list
	if [ $? -eq 0 ]; then
		sqlite3 -echo -cmd '.timeout 150000' $DataBase "DELETE FROM list WHERE list_id = '$FnGet_List_ID'"
	else
		sqlite3 -cmd '.timeout 150000' $DataBase "UPDATE list SET is_active = '0' WHERE list_id = '$FnGet_List_ID';"
		FnMail_Object="$MailObjectKO"
	fi

	echo
	echo "--------------------"
	echo "Date:		`/bin/date +%Y/%m/%d`"
	echo "Hour:		`/bin/date +%H:%M:%S`"
	echo "##### END #####"

	# E-mail notification
	content="$FileLogTemp"
	curl --data "username=$UserName&get_custom1=$FnLine&get_name=$FnGet_Name&subject=$FnMail_Object&content=$content" http://localhost:8888/rTorrent.php

	# Unset
	unset FnGet_Base_Bath FnGet_Custom1 FnGet_Name FnGet_LoadedFile FnCategoryDir FnGet_NameEscaped FnLine FnSubDirectory FnGet_LoadedFileEscaped
}
############ FUNCTIONs - BoF ############

#### EXECUTING: We read the list line by line.
sqlite3 -cmd '.timeout 150000' $DataBase "SELECT * FROM list WHERE list_category = '$CategoryList' AND is_active = '1' LIMIT $MaxToSync;" | while read ROW; do
	FileLogTemp="/tmp/$UserName-$ScriptName.log.$PID"
	list_id="`echo $ROW | awk '{split($0,a,"|"); print a[1]}'`"
	get_base_path="`echo $ROW | awk '{split($0,a,"|"); print a[4]}'`"
	get_custom1="`echo $ROW | awk '{split($0,a,"|"); print a[5]}'`"
	get_name="`echo $ROW | awk '{split($0,a,"|"); print a[6]}'`"
	get_loaded_file="`echo $ROW | awk '{split($0,a,"|"); print a[7]}'`"
	CategoryDir="`echo $ROW | awk '{split($0,a,"|"); print a[8]}'`"

	# Real process of synchronization
	Listing "$list_id" "$get_base_path" "$get_custom1" "$get_name" "$get_loaded_file" "$CategoryDir" &> $FileLogTemp

	# Move log file content
	if [ -f $FileLogTemp ]; then
		cat $FileLogTemp >> $FileLog
		rm -f $FileLogTemp
	fi
done

#### Removing the lock file
if [ -e $FileLock ]; then
	rm -f $FileLock
fi
